<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MTG Card Lookup (Browser CLIP)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 1rem; }
    #queryImg { max-width: 256px; margin-top: 1rem; display:block; }
    #results > div { margin: 0.8rem 0; }
    #spinner { display:none; margin: 0.8rem 0; color:#555; }
    code { background:#f4f4f4; padding:0.15rem 0.35rem; border-radius:4px; }
  </style>
</head>
<body>
  <h1>MTG Card Lookup</h1>
  <p>Pick a local image (a card or cropped art). The model runs fully in your browser.</p>

  <input type="file" id="fileInput" accept="image/*" disabled />
  <div id="spinner">Loading…</div>

  <img id="queryImg" alt="preview" />
  <div id="results"></div>

  <script type="module">
    import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers/dist/transformers.min.js";

    const D = 512;
    let meta = null;
    let db = null;
    let extractor = null;

    // ----------------- Utilities -----------------
    function float16ToFloat32(uint16) {
      const out = new Float32Array(uint16.length);
      for (let i = 0; i < uint16.length; i++) {
        const h = uint16[i];
        const s = (h & 0x8000) >> 15;
        const e = (h & 0x7C00) >> 10;
        const f = h & 0x03FF;
        let v;
        if (e === 0) v = (f ? (f / 1024) * Math.pow(2, -14) : 0);
        else if (e === 31) v = f ? NaN : Infinity;
        else v = (1 + f / 1024) * Math.pow(2, e - 15);
        out[i] = (s ? -1 : 1) * v;
      }
      return out;
    }
    function l2norm(x) {
      let s = 0;
      for (let i = 0; i < x.length; i++) s += x[i]*x[i];
      s = Math.sqrt(s) || 1;
      for (let i = 0; i < x.length; i++) x[i] /= s;
      return x;
    }
    async function toImageBitmap(file) {
      if ('createImageBitmap' in window) {
        try {
          return await createImageBitmap(file);
        } catch { /* fall through */ }
      }
      // Fallback via <img> -> <canvas>
      const img = await new Promise((resolve, reject) => {
        const _img = new Image();
        _img.onload = () => resolve(_img);
        _img.onerror = reject;
        _img.src = URL.createObjectURL(file);
      });
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      return canvas; // canvas is also accepted by transformers.js
    }
    function toImageDataFromElement(imgEl) {
      const canvas = document.createElement('canvas');
      const w = imgEl.naturalWidth || imgEl.width;
      const h = imgEl.naturalHeight || imgEl.height;
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imgEl, 0, 0);
      return ctx.getImageData(0, 0, w, h);
    }

    // ----------------- Data + Model -----------------
    async function loadEmbeddingsAndMeta() {
      console.log("Loading embeddings + metadata…");
      meta = await (await fetch("index_out/meta.json")).json();
      const buf = await (await fetch("index_out/embeddings.f16bin")).arrayBuffer();
      db = float16ToFloat32(new Uint16Array(buf));
      console.log(`Loaded ${meta.length} embeddings`);
    }

    async function loadModel() {
      const spinner = document.getElementById("spinner");
      spinner.style.display = "block";
      spinner.textContent = "Downloading CLIP (vision) model…";
      console.log("Loading CLIP vision model (first load may take a bit)…");
      extractor = await pipeline(
        "image-feature-extraction",
        "Xenova/clip-vit-base-patch32",
        {
          quantized: false,
          progress_callback: (p) => {
            const msg = `${p.status} ${p.progress ?? ""} ${p.file ?? ""}`;
            spinner.textContent = msg;
            console.log(msg);
          }
        }
      );
      spinner.style.display = "none";
      console.log("Model ready");
      document.getElementById("fileInput").disabled = false;
    }

    // ----------------- Embedding + Search -----------------
    async function embedFile(file, imgEl) {
      const url = imgEl.src; // already a blob: URL
      console.log("Calling extractor with blob URL:", url);
      const out = await extractor(url);
      return l2norm(Float32Array.from(out.data));
    }

    function topK(query, K=5) {
      const N = meta.length;
      const scores = new Float32Array(N);
      for (let i = 0; i < N; i++) {
        let s = 0, off = i * D;
        for (let j = 0; j < D; j++) s += query[j] * db[off + j];
        scores[i] = s;
      }
      const idx = [...scores.keys()];
      idx.sort((a,b) => scores[b] - scores[a]);
      return idx.slice(0, K).map(i => ({ score: scores[i], ...meta[i] }));
    }

    // ----------------- UI wiring -----------------
    function handleFileChange(e) {
      const file = e.target.files?.[0];
      if (!file) return;

      const imgEl = document.getElementById("queryImg");
      imgEl.onload = async () => {
        const spinner = document.getElementById("spinner");
        spinner.style.display = "block";
        spinner.textContent = "Embedding image…";
        try {
          const q = await embedFile(file, imgEl);
          spinner.textContent = "Searching…";
          const results = topK(q, 5);
          const resDiv = document.getElementById("results");
          resDiv.innerHTML = "";
          results.forEach(r => {
            const card = document.createElement("div");
            card.innerHTML = `
              <b>${r.name}</b> [${r.set}] (score ${r.score.toFixed(3)})<br>
              <img src="${r.image_url}" width="180" loading="lazy">
            `;
            resDiv.appendChild(card);
          });
          spinner.style.display = "none";
          console.log("Done.");
        } catch (err) {
          console.error("Embedding/search failed:", err);
          document.getElementById("spinner").textContent =
            "Failed to embed/search (see console).";
        }
      };
      // Show preview (and give us a DOM source for ImageData fallback)
      imgEl.src = URL.createObjectURL(file);
    }

    // ----------------- Init -----------------
    window.addEventListener("DOMContentLoaded", async () => {
      await loadEmbeddingsAndMeta();
      await loadModel();
      document.getElementById("fileInput").addEventListener("change", handleFileChange);
    });
  </script>
</body>
</html>
