# Python Artifacts Data Contract

**Version**: 1.0
**Last Updated**: 2025-10-13
**Source**: Generated by `packages/mtg-image-db/build_embeddings.py`
**Consumer**: `packages/mtg-image-db/query_index.py` and other Python tools

## Overview

Python artifacts enable local FAISS-based similarity search for development, testing, and batch processing. These files are the source of truth for card embeddings and are used to generate browser artifacts.

## File: `mtg_embeddings.npy`

### NumPy Array Specification

**Format**: NumPy binary format (.npy)
**Data Type**: `float32`
**Shape**: `[N, 512]` where N = number of cards
**Normalization**: L2-normalized (||v|| = 1.0 for each row)

### Properties

**Embedding Dimension**: 512 (CLIP ViT-B/32 output)
**Normalization**: Each vector is L2-normalized before saving
**Byte Order**: Native (typically little-endian)
**Compression**: None (raw float32)

### Validation

```python
import numpy as np

# Load embeddings
embeddings = np.load('index_out/mtg_embeddings.npy')

# Validate shape
assert embeddings.ndim == 2, "Embeddings must be 2D array"
assert embeddings.shape[1] == 512, f"Expected 512 dimensions, got {embeddings.shape[1]}"

# Validate data type
assert embeddings.dtype == np.float32, f"Expected float32, got {embeddings.dtype}"

# Validate normalization (within floating point tolerance)
norms = np.linalg.norm(embeddings, axis=1)
assert np.allclose(norms, 1.0, atol=1e-6), "Embeddings must be L2-normalized"
```

### Example Usage

```python
import numpy as np

# Load embeddings
embeddings = np.load('index_out/mtg_embeddings.npy')
print(f"Loaded {embeddings.shape[0]} card embeddings")

# Access individual embedding
card_embedding = embeddings[0]  # Shape: (512,)

# Compute similarity (dot product for normalized vectors = cosine similarity)
query_embedding = np.random.randn(512)
query_embedding /= np.linalg.norm(query_embedding)  # Normalize
similarities = embeddings @ query_embedding  # Shape: (N,)
top_k_indices = np.argsort(similarities)[::-1][:5]  # Top 5 matches
```

## File: `mtg_cards.faiss`

### FAISS Index Specification

**Index Type**: `IndexHNSWFlat`
**Metric**: Inner Product (IP)
**Dimension**: 512
**HNSW Parameters**:
- `M`: 64 (number of connections per layer)
- `efConstruction`: 400 (search quality during construction)

### Properties

**Why HNSW**: Provides 10-100x speedup over brute force with minimal accuracy loss
**Why Inner Product**: Equivalent to cosine similarity for L2-normalized vectors
**Memory**: ~50-100 MB for 50k cards (depends on M parameter)

### Construction

```python
import faiss
import numpy as np

# Load embeddings (must be L2-normalized)
embeddings = np.load('index_out/mtg_embeddings.npy')

# Create HNSW index
dimension = 512
M = 64  # Number of connections per layer
index = faiss.IndexHNSWFlat(dimension, M)
index.hnsw.efConstruction = 400  # Search quality during construction

# Add vectors
index.add(embeddings)

# Save index
faiss.write_index(index, 'index_out/mtg_cards.faiss')
```

### Query

```python
import faiss
import numpy as np

# Load index
index = faiss.read_index('index_out/mtg_cards.faiss')

# Set search quality (higher = more accurate but slower)
index.hnsw.efSearch = 64  # Default, can increase for better accuracy

# Query
query_embedding = np.random.randn(1, 512).astype('float32')
query_embedding /= np.linalg.norm(query_embedding)  # Normalize

k = 5  # Number of results
distances, indices = index.search(query_embedding, k)

# distances: cosine similarities (higher = more similar)
# indices: row indices in mtg_embeddings.npy
```

### Validation

```python
import faiss

# Load index
index = faiss.read_index('index_out/mtg_cards.faiss')

# Validate properties
assert index.d == 512, f"Expected dimension 512, got {index.d}"
assert index.ntotal > 0, "Index is empty"
assert isinstance(index, faiss.IndexHNSWFlat), "Expected IndexHNSWFlat"

print(f"Index contains {index.ntotal} vectors")
print(f"HNSW M: {index.hnsw.M}")
print(f"HNSW efConstruction: {index.hnsw.efConstruction}")
```

## File: `mtg_meta.jsonl`

### JSON Lines Specification

**Format**: JSON Lines (one JSON object per line)
**Encoding**: UTF-8
**Line Count**: Must equal `N` (number of embeddings)
**Order**: Same order as rows in `mtg_embeddings.npy`

### Record Schema

Each line is a JSON object with the following fields:

**Required Fields**:
- `name` (string): Card name
- `set` (string): Set code (e.g., "MH2")
- `image_url` (string): URL to card image
- `card_url` (string): URL to full card display

**Optional Fields**:
- `scryfall_id` (string): Scryfall UUID
- `face_id` (string): Face identifier for multi-face cards
- `collector_number` (string): Collector number
- `frame` (string): Frame style (e.g., "2015", "1993")
- `layout` (string): Card layout type (e.g., "normal", "transform")
- `lang` (string): Language code (e.g., "en")
- `colors` (array of strings): Color identity (e.g., ["R", "G"])
- `scryfall_uri` (string): Link to Scryfall page

### Example Records

```jsonl
{"name": "Lightning Bolt", "set": "LEA", "scryfall_id": "abc123", "face_id": "0", "collector_number": "161", "frame": "1993", "layout": "normal", "lang": "en", "colors": ["R"], "image_url": "https://cards.scryfall.io/normal/front/...", "card_url": "https://cards.scryfall.io/large/front/...", "scryfall_uri": "https://scryfall.com/card/lea/161/lightning-bolt"}
{"name": "Black Lotus", "set": "LEA", "scryfall_id": "def456", "face_id": "0", "collector_number": "232", "frame": "1993", "layout": "normal", "lang": "en", "colors": [], "image_url": "https://cards.scryfall.io/normal/front/...", "card_url": "https://cards.scryfall.io/large/front/...", "scryfall_uri": "https://scryfall.com/card/lea/232/black-lotus"}
```

### Loading Metadata

```python
import json

# Load all metadata
metadata = []
with open('index_out/mtg_meta.jsonl', 'r', encoding='utf-8') as f:
    for line in f:
        metadata.append(json.loads(line))

print(f"Loaded {len(metadata)} card records")

# Access metadata for a specific card
card_index = 42
card_info = metadata[card_index]
print(f"Card: {card_info['name']} ({card_info['set']})")
```

### Validation

```python
import json
import numpy as np

# Load embeddings to get expected count
embeddings = np.load('index_out/mtg_embeddings.npy')
expected_count = embeddings.shape[0]

# Load and validate metadata
metadata = []
with open('index_out/mtg_meta.jsonl', 'r', encoding='utf-8') as f:
    for i, line in enumerate(f):
        record = json.loads(line)
        
        # Validate required fields
        assert 'name' in record, f"Missing 'name' in record {i}"
        assert 'set' in record, f"Missing 'set' in record {i}"
        assert 'image_url' in record, f"Missing 'image_url' in record {i}"
        assert 'card_url' in record, f"Missing 'card_url' in record {i}"
        
        metadata.append(record)

# Validate count
assert len(metadata) == expected_count, \
    f"Metadata count mismatch: expected {expected_count}, got {len(metadata)}"

print(f"✓ Validated {len(metadata)} metadata records")
```

## Data Consistency Rules

### Cross-File Consistency

All three files MUST maintain consistent ordering and counts:

```python
import numpy as np
import faiss
import json

# Load all artifacts
embeddings = np.load('index_out/mtg_embeddings.npy')
index = faiss.read_index('index_out/mtg_cards.faiss')
metadata = []
with open('index_out/mtg_meta.jsonl', 'r') as f:
    for line in f:
        metadata.append(json.loads(line))

# Validate consistency
N = embeddings.shape[0]
assert index.ntotal == N, f"Index count mismatch: {index.ntotal} != {N}"
assert len(metadata) == N, f"Metadata count mismatch: {len(metadata)} != {N}"

print(f"✓ All artifacts consistent: {N} cards")
```

### Embedding-Metadata Alignment

The i-th row in `mtg_embeddings.npy` MUST correspond to:
- The i-th vector in `mtg_cards.faiss`
- The i-th line in `mtg_meta.jsonl`

This alignment is critical for correct search results.

## Performance Characteristics

### File Sizes (for 50,000 cards)

- `mtg_embeddings.npy`: ~100 MB (50,000 * 512 * 4 bytes)
- `mtg_cards.faiss`: ~50-100 MB (depends on HNSW parameters)
- `mtg_meta.jsonl`: ~5-10 MB (depends on metadata richness)
- **Total**: ~155-210 MB

### Query Performance

**Brute Force** (IndexFlatIP):
- Query time: ~10-50ms for 50k cards
- Accuracy: 100% (exact)

**HNSW** (IndexHNSWFlat with M=64, efSearch=64):
- Query time: ~0.5-2ms for 50k cards
- Accuracy: >99% (approximate)
- **Speedup**: 10-100x faster

### Build Performance

**Embedding Generation** (CLIP ViT-B/32):
- CPU: ~2-5 seconds per card
- GPU (CUDA): ~0.1-0.5 seconds per card
- MPS (Apple Silicon): ~0.5-1 second per card

**FAISS Index Construction**:
- Time: ~10-30 seconds for 50k cards
- Memory: ~200-300 MB peak

## Export to Browser

Python artifacts are the source for browser artifacts:

```bash
python export_for_browser.py
```

This script:
1. Loads `mtg_embeddings.npy`
2. Quantizes float32 → int8 (multiply by 127, clip to [-127, 127])
3. Saves as `embeddings.i8bin`
4. Loads `mtg_meta.jsonl`
5. Wraps in JSON object with version and quantization metadata
6. Saves as `meta.json`

See `contracts/browser-artifacts.md` for browser format details.

## References

- Source specification: `packages/mtg-image-db/SPEC.md` section 6.1
- Build script: `packages/mtg-image-db/build_embeddings.py`
- Export script: `packages/mtg-image-db/export_for_browser.py`
- Query script: `packages/mtg-image-db/query_index.py`
