# Signaling API Contract

**Feature**: 001-webrtc-video-streaming  
**Version**: 1.0.0  
**Date**: 2025-01-27

## Overview

Signaling API for WebRTC peer-to-peer video streaming. Uses TanStack Start patterns:
- **Client → Server**: `createServerFn` (request/response)
- **Server → Client**: SSE (Server-Sent Events, real-time)

## Client → Server: Send Signaling Message

**Endpoint**: `createServerFn('sendSignalingMessage')`

**Method**: POST (via TanStack Start createServerFn)

**Request**:
```typescript
{
  roomId: string;           // Game room ID
  to: string;               // Target player ID
  message: {
    type: 'offer' | 'answer' | 'ice-candidate';
    payload: SignalingPayload;
  };
}
```

**SignalingPayload**:
```typescript
// For type: 'offer' | 'answer'
{
  type: 'offer' | 'answer';
  sdp: string;              // SDP string from RTCSessionDescription
}

// For type: 'ice-candidate'
{
  candidate: string;        // ICE candidate string
  sdpMLineIndex: number | null;
  sdpMid: string | null;
}
```

**Response**:
```typescript
{
  success: boolean;
  error?: string;           // Error message if success is false
}
```

**Validation Rules**:
- `roomId` must match current room
- `to` must be valid player ID in room
- `message.type` must be valid type
- `payload` structure must match `type`
- SDP must be valid WebRTC format

**Error Cases**:
- `400`: Invalid request (missing fields, invalid format)
- `403`: Player not in room
- `404`: Target player not found or not connected
- `500`: Server error

## Server → Client: Receive Signaling Message

**Channel**: SSE stream (existing `/api/stream` endpoint)

**Message Format**:
```typescript
{
  v: 1;                     // Version
  type: 'webrtc-signaling';
  event: 'signaling-message';
  ts: number;               // Timestamp
  data: {
    from: string;           // Source player ID
    roomId: string;         // Game room ID
    message: {
      type: 'offer' | 'answer' | 'ice-candidate';
      payload: SignalingPayload;
    };
  };
}
```

**Delivery**:
- Messages routed to players in same room
- Delivered via existing SSE connection
- Real-time delivery (no polling)

**Filtering**:
- Client filters messages by `roomId` and `from`
- Only processes messages for current room
- Ignores messages from self

## Message Types

### Offer

**Purpose**: Initiate peer connection.

**Flow**:
1. Player A creates RTCPeerConnection
2. Player A creates offer: `await peerConnection.createOffer()`
3. Player A sets local description: `await peerConnection.setLocalDescription(offer)`
4. Player A sends offer via `sendSignalingMessage` to Player B
5. Backend routes to Player B via SSE
6. Player B receives offer, creates answer

**Payload**:
```typescript
{
  type: 'offer';
  sdp: string;  // RTCSessionDescription.sdp
}
```

### Answer

**Purpose**: Respond to offer.

**Flow**:
1. Player B receives offer via SSE
2. Player B creates RTCPeerConnection
3. Player B sets remote description: `await peerConnection.setRemoteDescription(offer)`
4. Player B creates answer: `await peerConnection.createAnswer()`
5. Player B sets local description: `await peerConnection.setLocalDescription(answer)`
6. Player B sends answer via `sendSignalingMessage` to Player A
7. Backend routes to Player A via SSE
8. Player A receives answer, sets remote description

**Payload**:
```typescript
{
  type: 'answer';
  sdp: string;  // RTCSessionDescription.sdp
}
```

### ICE Candidate

**Purpose**: Exchange network connectivity information.

**Flow**:
1. ICE candidate generated by RTCPeerConnection (`onicecandidate` event)
2. Send candidate via `sendSignalingMessage` to peer
3. Backend routes to peer via SSE
4. Peer receives candidate, adds to peer connection: `await peerConnection.addIceCandidate(candidate)`

**Payload**:
```typescript
{
  candidate: string;        // Full ICE candidate string
  sdpMLineIndex: number | null;
  sdpMid: string | null;
}
```

**Note**: Multiple ICE candidates sent per connection (one per network interface).

## Backend Routing Logic

**Room Mapping**:
```typescript
// Backend maintains:
Map<roomId, Set<userId>>  // Players in each room
Map<userId, SSEConnection> // SSE connections per player
```

**Routing**:
1. Receive message via `sendSignalingMessage`
2. Validate `roomId` and `to` player membership
3. Lookup SSE connection for `to` player
4. Emit SSE event with message
5. Return success response

**Error Handling**:
- If `to` player not in room: return 404
- If `to` player SSE not connected: return 404
- If routing fails: return 500

## Versioning

**Current Version**: 1.0.0

**Breaking Changes** (require MAJOR version bump):
- Message structure changes
- Field removals
- Type changes

**Non-Breaking Changes** (MINOR/PATCH):
- New optional fields
- Documentation updates
- Error message improvements

## Examples

### Sending Offer

```typescript
const offer = await peerConnection.createOffer();
await peerConnection.setLocalDescription(offer);

await sendSignalingMessage({
  roomId: 'room-123',
  to: 'player-b',
  message: {
    type: 'offer',
    payload: {
      type: 'offer',
      sdp: offer.sdp,
    },
  },
});
```

### Receiving Offer (via SSE)

```typescript
// In SSE event handler
if (event.type === 'webrtc-signaling' && event.data.message.type === 'offer') {
  const offer = new RTCSessionDescription({
    type: 'offer',
    sdp: event.data.message.payload.sdp,
  });
  await peerConnection.setRemoteDescription(offer);
  // Create answer...
}
```

### Sending ICE Candidate

```typescript
peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    sendSignalingMessage({
      roomId: 'room-123',
      to: 'player-b',
      message: {
        type: 'ice-candidate',
        payload: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid,
        },
      },
    });
  }
};
```

